
import { AlertEntity } from '../entities/Alert';
import { UserEntity } from '../entities/User';
import { TeamEntity } from '../entities/Team';
import { UserRepository } from '../repositories/UserRepository';
import { TeamRepository } from '../repositories/TeamRepository';
import { DeliveryStrategyFactory } from '../delivery/DeliveryStrategyFactory';
import { VisibilityType } from '../models/enums';
import { Notification } from '../models/Notification';
import { UserAlertStateRepository } from '../repositories/UserAlertStateRepository';
import { UserAlertStateEntity } from '../entities/UserAlertState';
import { NotificationStatus } from '../models/enums';

export class NotificationService {
  private userRepository: UserRepository;
  private teamRepository: TeamRepository;
  private userAlertStateRepository: UserAlertStateRepository;

  constructor(
    userRepository: UserRepository,
    teamRepository: TeamRepository,
    userAlertStateRepository: UserAlertStateRepository
  ) {
    this.userRepository = userRepository;
    this.teamRepository = teamRepository;
    this.userAlertStateRepository = userAlertStateRepository;
  }

  public async processAlert(alert: AlertEntity): Promise<void> {
    const targetUsers = await this.getTargetUsers(alert);

    for (const user of targetUsers) {
      await this.sendNotification(alert, user);
    }
  }

  private async getTargetUsers(alert: AlertEntity): Promise<UserEntity[]> {
    switch (alert.visibility.type) {
      case VisibilityType.ORGANIZATION:
        return this.userRepository.findAll(); // Assuming all users in the DB belong to the same org for this MVP
      case VisibilityType.TEAM:
        return this.userRepository.findByTeamId(alert.visibility.targetIds[0]);
      case VisibilityType.USER:
        return this.userRepository.findAllByIds(alert.visibility.targetIds);
      default:
        return [];
    }
  }

  private async sendNotification(alert: AlertEntity, user: UserEntity): Promise<void> {
    const deliveryStrategy = DeliveryStrategyFactory.createStrategy(alert.deliveryType);
    const notification: Notification = {
      id: '', // This will be generated by the delivery strategy
      alertId: alert.id,
      userId: user.id,
      status: NotificationStatus.SENT,
      createdAt: new Date(),
    };
    
    deliveryStrategy.send(notification);
  }

  public async scheduleReminders(alert: AlertEntity): Promise<void> {
    if (!alert.reminderEnabled) {
      return;
    }

    // Simulate recurring reminders every 2 hours
    setInterval(async () => {
      if (alert.isActive()) {
        const targetUsers = await this.getTargetUsers(alert);
        for (const user of targetUsers) {
          const userState = await this.userAlertStateRepository.findByUserIdAndAlertId(user.id, alert.id);

          if (!userState || (!userState.snoozed && userState.status !== NotificationStatus.READ)) {
            this.sendNotification(alert, user);
          }
        }
      } else {
        // Stop the interval if the alert is no longer active
        clearInterval(this as any); // `this` refers to the interval ID
      }
    }, alert.reminderFrequency * 60 * 60 * 1000); // reminderFrequency is in hours
  }
}
